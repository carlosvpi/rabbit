function asyncPick<T, TReturn = any, TNext = any> (indexes: number[], returnValue?: TReturn) {
  return async function* (g: AsyncGenerator<T, TReturn, TNext>): AsyncGenerator<T, TReturn, TNext> {
    let generation: T[] = []
    let next: TNext
    let iterator: IteratorResult<T, TReturn>
    for (let index of indexes) {
      while (!iterator?.done && index >= generation.length) {
        iterator = await g.next(next)
        if (iterator.done) {
          returnValue ||= iterator.value
        } else {
          generation.push(iterator.value as T)
        }
      }
      next = yield index >= generation.length ? undefined : generation[index]
    }
    return returnValue
  }
}

function syncPick<T, TReturn = any, TNext = any> (indexes: number[], returnValue?: TReturn) {
  return function* (g: Generator<T, TReturn, TNext>): Generator<T, TReturn, TNext> {
    let generation: T[] = []
    let next: TNext
    let iterator: IteratorResult<T, TReturn>
    for (let index of indexes) {
      while (!iterator?.done && index >= generation.length) {
        iterator = g.next(next)
        if (iterator.done) {
          returnValue ||= iterator.value
        } else {
          generation.push(iterator.value as T)
        }
      }
      next = yield index >= generation.length ? undefined : generation[index]
    }
    return returnValue
  }
}

/**
 * The `i`-th element of `pick(indexes)(g)` is the `j`-th item of `g` (potentially `undefined`, if `g` does not have `j` items), where `j` is the `i`-th item in `indexes`
 * 
 * `pick(indexes)(g)` passes down to `g` the `next` value passed to `pick` for each `i` in `indexes`, which does not correspond to the items generated by `g`.
 * 
 * `pick(indexes)(g)` returns the returning value of `g` if it finished.
 * 
 * `pick(indexes, returnValue)(g)` returns `returnValue` when either `indexes` or `g` end.
 * 
 * **Example** `pick([1, 0, 0, 2])(range())` generates 1, 0, 0, 2
 * @param {array} [indexes] the array of indexes
 * @param {array} [returnValue] the return value
 */

export function pick<T, TReturn = any, TNext = any> (indexes: number[], returnValue?: TReturn) {
  const asyncFunctor = asyncPick(indexes, returnValue)
  const syncFunctor = syncPick(indexes, returnValue)
  return function<G extends Generator<T, TReturn, TNext> | AsyncGenerator<T, TReturn, TNext>> (g: G): G {
    if (g[Symbol.asyncIterator]) {
      return asyncFunctor(g as AsyncGenerator<T, any, TNext>) as G;
    }
    return syncFunctor(g as Generator<T, any, TNext>) as G;
  }
}
