function* multicastFromNowAsync<T, TReturn = any> (g: AsyncGenerator<T, TReturn>): Generator<AsyncGenerator<T, TReturn>, never> {
  const stored = []
  let done: boolean = false
  let result: TReturn
  while (true) {
    const constructor = async function* (i: number) {
      let iterator: IteratorResult<T, TReturn>
      while (true) {
        if (i === stored.length) {
          if (done) return result
          iterator = await g.next()
          if (done = iterator.done) return result ||= iterator.value
          stored.push(iterator.value)
        }
        yield stored[i++]
      }
    }
    yield constructor(stored.length)
  }
}

function* multicastFromNowSync<T, TReturn = any> (g: Generator<T, TReturn>): Generator<Generator<T, TReturn>, never> {
  const stored = []
  let done: boolean = false
  let result: TReturn
  while (true) {
    const constructor = function* (i: number) {
      let iterator: IteratorResult<T, TReturn>
      while (true) {
        if (i === stored.length) {
          if (done) return result
          iterator = g.next()
          if (done = iterator.done) return result ||= iterator.value
          stored.push(iterator.value)
        }
        yield stored[i++]
      }
    }
    yield constructor(stored.length)
  }
}

/**
 * `multicastFromNow(g)` generates independent copies of g.
 * 
 * `g` is required to not have a type of `next`
 * 
 * The return value of each copy is the same as that of the original generator `g` (but does not replay all previous items generated by `g`).
 * 
 * `multicastFromNow(g)` never returns.
 * 
 * @param {number} [g] the generator to multicastFromNow
 */

export function multicastFromNow<T, TReturn = any> (g: Generator<T, TReturn>): Generator<Generator<T, TReturn>, never>
export function multicastFromNow<T, TReturn = any> (g: AsyncGenerator<T, TReturn>): Generator<AsyncGenerator<T, TReturn>, never>

export function multicastFromNow<T, TReturn = any> (g: Generator<T, TReturn> | AsyncGenerator<T, TReturn>): Generator<Generator<T, TReturn> | AsyncGenerator<T, TReturn>, never> {
  if (g[Symbol.asyncIterator]) {
    return multicastFromNowAsync(g as AsyncGenerator<T, any>) as Generator<AsyncGenerator<T, TReturn>, never>;
  }
  return multicastFromNowSync(g as Generator<T, any>) as Generator<Generator<T, TReturn>, never>;
}
