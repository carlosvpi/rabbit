/**
 * The `i`-th element of `asyncPick(indexes)(g)` is the `j`-th item of `g` (potentially `undefined`, if `g` does not have `j` items), where `j` is the `i`-th item in `indexes`
 * 
 * `asyncPick(indexes)(g)` passes down to `g` the `next` value passed to `asyncPick` for each `i` in `indexes`, which does not correspond to the items generated by `g`.
 * 
 * `asyncPick(indexes)(g)` returns the returning value of `g` if it finished.
 * 
 * `asyncPick(indexes, returnValue)(g)` returns `returnValue` when either `indexes` or `g` end.
 * 
 * **Example** `asyncPick([1, 0, 0, 2])(toAsync(range()))` generates 1, 0, 0, 2
 * @param {array} [indexes] the array of indexes
 * @param {array} [returnValue] the return value
 */

export function asyncPick<T, TReturn = any, TNext = any> (indexes: number[], returnValue?: TReturn) {
  return async function* (g: AsyncGenerator<T, TReturn, TNext>): AsyncGenerator<T, TReturn, TNext> {
    let generation: T[] = []
    let next: TNext
    let iterator: IteratorResult<T, TReturn>
    for (let index of indexes) {
      while (!iterator?.done && index >= generation.length) {
        iterator = await g.next(next)
        if (iterator.done) {
          returnValue ||= iterator.value
        } else {
          generation.push(iterator.value as T)
        }
      }
      next = yield index >= generation.length ? undefined : generation[index]
    }
    return returnValue
  }
}
