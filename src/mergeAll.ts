/**
 * 
 * `mergeAll(g1, g2, ...)` generates the items of gi,... as they are generated by the generators. It returns the array of values returned by the generators in the order they end.
 * 
 * ```typescript
 * clock           0   1   2   3   4   5   6   7   8   9
 * g              «a   b           e           h   i | y»
 * h              «        c   d       f   g | x»
 * mergeAll(g,h)  «a   b   c   d   e   f   g   h   i | [x, y]»
 * ```
 * 
 * @param gs Array of asynchronous generators
 * @returns merged generator
 */

export async function* mergeAll<T, TReturn = any, TNext = any> (...gs: AsyncGenerator<T, TReturn, TNext>[]): AsyncGenerator<T, TReturn, TNext> {
  let iterator: IteratorResult<T, TReturn>
  let iterators: IteratorResult<T, TReturn>[] = []
  let next: TNext
  let returnValue: TReturn[] = []
  let resolver: (value: IteratorResult<T, TReturn> | PromiseLike<IteratorResult<T, TReturn>>) => void
  let freeResolver: boolean = true
  const freeGenerators = new Set<AsyncGenerator<T, TReturn, TNext>>(gs)
  while (returnValue.length < gs.length) {
    iterator = await new Promise(resolve => {
      resolver = resolve
      freeResolver = true
      if (iterators.length) {
        resolver(iterators.splice(0, 1)[0])
        return
      }
      gs.forEach(async (g) => {
        if (!freeGenerators.has(g)) return
        freeGenerators.delete(g)
        iterators.push(await g.next(next))
        if (!iterators.at(-1).done) freeGenerators.add(g)
        if (freeResolver) {
          resolver(iterators.splice(0, 1)[0] as IteratorResult<T>)
          freeResolver = false
        }
      })
    })
    if (iterator.done) {
      returnValue.push(iterator.value as TReturn)
    } else {
      next = yield iterator.value as T
    }
  }
  return returnValue as TReturn
}
