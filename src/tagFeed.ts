async function* asyncTagFeed<T, TReturn = any, TNext = T>(g: AsyncGenerator<T, TReturn, TNext>): AsyncGenerator<(T | TNext)[], (TReturn | TNext)[], TNext> {
  let next: TNext
  let iterator: IteratorResult<T, TReturn>
  while (!(iterator = await g.next(next)).done) {
    next = yield [iterator.value as T, next]
  }
  return [iterator.value as TReturn, next]
}

function* syncTagFeed<T, TReturn = any, TNext = T>(g: Generator<T, TReturn, TNext>): Generator<(T | TNext)[], (TReturn | TNext)[], TNext> {
  let next: TNext
  let iterator: IteratorResult<T, TReturn>
  while (!(iterator = g.next(next)).done) {
    next = yield [iterator.value as T, next]
  }
  return [iterator.value as TReturn, next]
}

/**
 * 
 * `tagFeed(g)` generates `[e, n]`, where `e` is an item generated by `g` and `n` is the next value passed to generate `e`.
 * 
 * `tagFeed(g)` returns `[r, n]`, where `r` is the return value of `r` and `n` is the next value passed to end `g`.
 * 
 * @param g the generator whose feed is to be tagged
 * @returns 
 */

export function tagFeed<T, TReturn = any, TNext = T>(g: AsyncGenerator<T, TReturn, TNext>): AsyncGenerator<(T | TNext)[], (TReturn | TNext)[], TNext>
export function tagFeed<T, TReturn = any, TNext = T>(g: Generator<T, TReturn, TNext>): Generator<(T | TNext)[], (TReturn | TNext)[], TNext>

export function tagFeed<T, TReturn = any, TNext = T>(g: AsyncGenerator<T, TReturn, TNext> | Generator<T, TReturn, TNext>): AsyncGenerator<(T | TNext)[], (TReturn | TNext)[], TNext> | Generator<(T | TNext)[], (TReturn | TNext)[], TNext> {
  if (g[Symbol.asyncIterator]) {
    return asyncTagFeed(g as AsyncGenerator<T, TReturn, TNext>) as AsyncGenerator<(T | TNext)[], (TReturn | TNext)[], TNext>;
  }
  return syncTagFeed(g as Generator<T, TReturn, TNext>) as Generator<(T | TNext)[], (TReturn | TNext)[], TNext>;
}
