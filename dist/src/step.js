"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.step = step;
function asyncStep(distance = 1, returnValue) {
    return async function* (g) {
        let next;
        let iterator;
        let current = 1;
        while (!(iterator = await g.next(next)).done) {
            if (--current)
                continue;
            current = distance;
            next = yield iterator.value;
        }
        return returnValue !== null && returnValue !== void 0 ? returnValue : iterator.value;
    };
}
function syncStep(distance = 1, returnValue) {
    return function* (g) {
        let next;
        let iterator;
        let current = 1;
        while (!(iterator = g.next(next)).done) {
            if (--current)
                continue;
            current = distance;
            next = yield iterator.value;
        }
        return returnValue !== null && returnValue !== void 0 ? returnValue : iterator.value;
    };
}
/**
 * `step(distance)(g)` gets the elements of `g` separated `distance` items between each.
 *
 * `step(distance, returnValue)(g)` returns `returnValue` if specified. Otherwise, it returns the returned value of `g`.
 *
 * **Example** `step(5)(range())` generates 0, 5, 10, 15...
 *
 * @param {number} [distance=0] The index difference of items of `g` to be generated by `step(distance)(g)`
 */
function step(distance = 1, returnValue) {
    const asyncFunctor = asyncStep(distance, returnValue);
    const syncFunctor = syncStep(distance, returnValue);
    return function (g) {
        if (g[Symbol.asyncIterator]) {
            return asyncFunctor(g);
        }
        return syncFunctor(g);
    };
}
