## Functions

### append

```typescript
function append<T, I> (object: Generator<I>): (g: Generator<T, any, I>) => Generator<T, any, I>
```

`append(g1)(g2)` generates, first, all items from `g2`, and then all items from `g1`

**Example**

`append(range(5))(range(0, 5))` generates `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...`

### feed

```typescript
function feed<T, I> (feeder?: Generator<I>): (g: Generator<T, any, I>) => Generator<T, any, I>
```

`feed(feeder)(g)` is simmilar to `g`, except that items are obtained passing what `feeder` generates to `g.next`.

* The first time, `feed(feeder)(g).next() ~~ g.next()`
* For any successive call `feed(feeder)(g).next() ~~ g.next(feeder.next())`

**Example**

If `feeder` generates numbers `0`, `1`, `2`, ...

and `g.next(n)` generates `2 * (n ?? 0)`

Then `feed(feeder)(g)` generates `0`, `2`, `4`, ...

### feedback

```typescript
function feedback<T, I> (feeder?: Generator<I>): (g: Generator<T, any, I>) => Generator<T, any, I>
```

`feedback(feeder)(g)` is simmilar to `g`, except that items are obtained passing what `feeder` generates to `g.next`. Also, `feeder.next` is passed the previous item generated by `g`.

* The first time, `e = feedback(feeder)(g).next() ~~ g.next()`
* For any successive call `e = feedback(feeder)(g).next() ~~ g.next(feeder.next(e))`

**Example**

If `feeder.next(n)` generates numbers `2 * (n ?? 0)`, ...

and `g.next(n)` generates `1 + (n ?? 0)`

Then `feedback(feeder)(g)` generates `1, 1, 3, 7, 15, 31, ...`

### feedMap

```typescript
function feedMap<T, U> (f: (_: T) => U, first: T): Generator<U, any, T>
```

`feedMap(f, first)` is a generator that applies `f` to its *next parameter*.

* The first time, `feedMap(f, first).next(_) ~~ f(first)`
* For any successive call `feedMap(f, first).next(n) ~~ f(n)`

`feedMap` is a convenient generator to pass to `feed` and `feedback`.

**Example**

`feeder.next(x => 2 * x, 0)`, when passing increasing numbers from 1 to n, generates numbers `0, 2, 4, 6, 8, ...

### filter

```typescript
function filter<T> (p: (_0: T, _1: number) => boolean): (g: Generator<T>) => Generator<T>
```

`filter(p)` takes a generator `g` and generates items `e` of `g` such that `p(e, i) === true`, with `i` the index of `e` on `g`.

### flatMap

```typescript
function flatMap<T, U> (f: (_: T) => Generator<U>): (g: Generator<T>) => Generator<T>
```

`flatMap(f)(g)` takes a generator `g` and applies to each of its items `e`, the function `f`. The result, `f(e)` is another generator. `flatMap` flattens the resulting generator.

**Example**

`flatMap(x => range(0, x))(fromArray([3, 2, 6]))`, generates `0, 1, 2, 0, 1, 0, 1, 2, 3, 4, 5`

### fromArray

```typescript
function fromArray<N>(array: N[]): Generator<N>
```

`fromArray` takes an array `array` generates, one by one, the elements in `array`.

### head

```typescript
function head<T> (n: number): (g: Generator<T>) => Generator<T>
```

`head(n)` takes a generator `g` and generates its first `n` (default `n` = 1) items.

### headWhile

```typescript
function headWhile<T> (p: (_0: T, _1: number) => boolean): (g: Generator<T>) => Generator<T>
```

`headWhile(p)` takes a generator `g` and generates its items from the first onwards while each item `e` fulfill `p(e, i)`, with `i` the index of `e` on `g`.

### map

```typescript
function map<T, U> (f: (_0: T, _1: number) => U): (g: Generator<T>) => Generator<T>
```

`map(f)` takes a generator `g` and generates for each `e` of `g`, the value `f(e, i)`, with `i` the index of `e` on `g`.

### pick

```typescript
function pick<T> (indexes: number[]): (g: Generator<T>) => Generator<T> { 
```

### pickFeed

```typescript
function pickFeed<T> (pick: Generator<number, any, T>): (g: Generator<T>) => Generator<T> { 
```

`pickFeed(pick)(g)` generates the items of `g` with indexes separated the distances generated by `pick.next({{previous call to}} g.next())`

**Example**

`pickFeed(fromArray([0, 0, 7, 0]))(range())` generates 0, 0, 7, 0

### pipe

```typescript
function pipe<N>(...constructors: ((_: Generator<N>) => Generator<N>)[]): (generator: Generator<N>) => Generator<N>
```

`pipe(...c)(g)` generates items of `g` and passes them through the generator constructors `c_i`

**Example**

`pipe(skip(5), head(10), filter(x => x % 2 === 0))(range())` generates 6, 8, 10, 12, 14

### prepend

```typescript
function prepend<T, I> (object: Generator<I>): (g: Generator<T, any, I>) => Generator<T, any, I>
```

`prepend(g1)(g2)` generates, first, all items from `g1`, and then all items from `g2`

**Example**

`prepend(range(0, 5))(range(5))` generates `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...`

### range

```typescript
function* range(start: number = 0, end: number = Infinity, step: number = 1): Generator<number>
```

`range(start, end, step)` generates numbers from `start` (included) to `end` (excluded) distanced a `step`, either increasing or decreasing

**Examples**

`range(1, 10)` generates 1, 2, 3, 4, 5, 6, 7, 8, 9

`range(10, 1, 2)` generates 10, 8, 6, 4, 2

### reduce

```typescript
function reduce<T, U> (f: (_0: U, _1: T, _2: number) => U, u?: U): (generator: Generator<T>) => Generator<U>
```

`reduce(f, dflt)(g)` generates items `r[i] = f(r[i-1], e)`, and `r[0] = d`

**Example**

`reduce((acc, x) => acc + x, 0)(range(0, 5))` generates 0, 1, 3, 6, 10

### runningTuples

```typescript
function runningTuples<T> (size: number = 1): (g: Generator<T>) => Generator<T>
```

`runningTuples(size)(g)` gets the elements of `g` grouped into runningTuples of `size` elements, repeating elements between tuples

**Example**

`runningTuples(3)(range())` generates [0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], ...

### skip

```typescript
function skip<T> (n: number): (g: Generator<T>) => Generator<T>
```

`skip(n)(g)` skips `n` items `e` of `g`. After skipping the items, it generates the same as `g`.

**Example**

`skip(5)(range(0, 10))` generates 5, 6, 7, 8, 9

### skipWhile

```typescript
function skipWhile<T> (p: (_0: T, _1: number) => boolean): (g: Generator<T>) => Generator<T>
```

`skipWhile(p)(g)` skips items `e` of `g` as long `p(e, i)` holds (`i` is the index of `e` in `g`). After skipping the items, it generates the same as `g`.

**Example**

`skipWhile(x => x % 6 !== 5)(range(0, 10))` generates 5, 6, 7, 8, 9

### slice

```typescript
function slice<T> (start: number = 0, end: number = Infinity, step: number = 1): (g: Generator<T>) => Generator<T>
```

`slice(start, end, step)(g)` gets items indexed `i` on `g`, where 0 <= `start` <= `i` < `end`, and if `i` is an index, the next index is `i + step`.

**Example**

`slice(5, 10)(range())` generates 5, 6, 7, 8, 9

`slice(5, 10, 2)(range())` generates 5, 7, 9

### step

```typescript
function step<T> (distance: number = 1): (g: Generator<T>) => Generator<T>
```

`step(distance)(g)` gets the elements of `g` separated `distance` items between each.

**Example**

`step(5)(range())` generates 0, 5, 10, 15...

### tuples

```typescript
function tuples<T> (size: number = 1): (g: Generator<T>) => Generator<T>
```

`tuples(size)(g)` gets the elements of `g` grouped into tuples of `size` elements

**Example**

`tuples(3)(range())` generates [0, 1, 2], [3, 4, 5], [6, 7, 8], ...