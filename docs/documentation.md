## Operators

### append

```typescript
function append<T, TReturn = any, TNext = any> (object: Generator<T, TReturn, TNext>): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`append(g1)(g2)` generates, first, all items from `g2`, and then all items from `g1`

`next` values passed to `append(g1)(g2)` are passed down to `g2`, first, and `g1`, after.

The return value of `g2` is ignored. The return value of `append(g1)(g2)` is that of `g1`.

**Example**

`append(range(5))(range(0, 5))` generates `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...`

### chunks

```typescript
function chunks<T, TReturn = any, TNext = any> (size: number = 1): (g: Generator<T, TReturn, TNext>) => Generator<T[], TReturn, TNext>
```
`chunks(size)(g)` gets the elements of `g` grouped into chunks of `size` elements

For each item of a chunk, `g` is invoked with the same `next` value.

**Example**

`chunks(3)(range())` generates `[0, 1, 2]`, `[3, 4, 5]`, `[6, 7, 8]`, ...

### every

```typescript
function every<T, TReturn = any, TNext = any> (p: (_0: T, _1: number, _2: TNext) => boolean): (g: Generator<T, TReturn, TNext>) => Generator<boolean, T | null, TNext>
```

`every(p)(g)` generates true until an element of `g` no longer satisfies a predicate, in which case it generates false.

It returns the value that did not fulfil `p`, if some, or `null`.

`every` does not apply `p` to the return value of `g`.

### feed

```typescript
function feed<T, TReturn = any, TFeederReturn = any, TNext = any, TFeederNext = any> (feeder: Generator<TNext, any, TFeederNext>): (g: Generator<T, any, TNext>) => Generator<T, FeedReturn<TReturn, TFeederReturn>, TFeederNext>
```

`feed(feeder)(g)` is simmilar to `g`, except that items are obtained passing what `feeder` generates to `g.next`.

* The first time, `feed(feeder)(g).next(x) ~~ g.next(x)`
* For any successive call `feed(feeder)(g).next(x) ~~ g.next(feeder.next(x))`
* If the generator `g` returns `value`, `feedback(feeder)(g)` returns `[value, null]`
* If the `feeder` returns `value`, `feedback(feeder)(g)` returns `[null, value]`
* If both the generator `g` and `feeder` return `value1` and `value2` at the same time, `feedback(feeder)(g)` returns `[value1, value2]`

**Example**

If `feeder` generates numbers `0`, `1`, `2`, ...

and `g.next(n)` generates `2 * (n ?? 0)`

Then `feed(feeder)(g)` generates `0`, `2`, `4`, ...

### feedback

```typescript
function feedback<T, TReturn = any, TFeederReturn = any, TNext = any> (feeder: Generator<TNext, TFeederReturn, T>): (g: Generator<T, TReturn, TNext>) => Generator<T, FeedReturn<TReturn, TFeederReturn>, any>
```

`feedback(feeder)(g)` is simmilar to `g`, except that items are obtained passing what `feeder` generates to `g.next`. Also, `feeder.next` is passed the previous item generated by `g`.

* The first time, `e = feedback(feeder)(g).next() ~~ g.next()`
* For any successive call `e = feedback(feeder)(g).next() ~~ g.next(feeder.next(e))`
* If the generator `g` returns `value`, `feedback(feeder)(g)` returns `[value, null]`
* If the `feeder` returns `value`, `feedback(feeder)(g)` returns `[null, value]`
* If both the generator `g` and `feeder` return `value1` and `value2` at the same time, `feedback(feeder)(g)` returns `[value1, value2]`

**Example**

If `feeder.next(n)` generates numbers `2 * (n ?? 0)`, ...

and `g.next(n)` generates `1 + (n ?? 0)`

Then `feedback(feeder)(g)` generates `1, 1, 3, 7, 15, 31, ...`

### feedMap

```typescript
function feedMap<T, TNext = T> (f: (_: TNext) => T, first: TNext): Generator<T, never, TNext>
```

`feedMap(f, first)` is a generator that applies `f` to its *next parameter*.

* The first time, `feedMap(f, first).next().value ~~ f(first)`
* For any successive call `feedMap(f, first).next(n).value ~~ f(n)`
* `feedMap(f, first)` never returns.

`feedMap` is a convenient generator to pass to `feed` and `feedback`.

**Example**

`feeder.next(x => 2 * x, 0)`, when passing increasing numbers from 1 to n, generates numbers `0, 2, 4, 6, 8, ...

### filter

```typescript
function filter<T, TReturn = any, TNext = any> (p: (_0: T, _1: number, _2: TNext) => boolean): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`filter(p)` takes a generator `g` and generates items `e` of `g` such that `p(e, i) === true`, with `i` the index of `e` on `g`.

`p` is passed each item and the index of the item.

`filter(p)(g)` returns the same value as `g` regardless of whether it passes `p`.

### find

```typescript
function find<T, TNext> (p: (_0: T, _1: number, _2: TNext) => boolean): (g: Generator<T, any, TNext>) => T | null
```

`find(p)(g)` finds the item in `g` that fulfils `p` (if none does, returns `null`)

`p` is passed each item, the index of the item and the `next` value used to get it.


**Example**

`find(x => x%5 === 4)(range(0, 5))` returns 4

### flatMap

```typescript
function flatMap<T, U, TReturn = any, UReturn = any, TNext = any> (f: (_: T, _1: number) => Generator<U, UReturn, TNext>): (g: Generator<T, TReturn, TNext>) => Generator<U, UReturn, TNext>
```

`flatMap(f)(g)` takes a generator `g` and applies to each of its items `e`, the function `f`. The result, `f(e)` is another generator. `flatMap` flattens the resulting generator.

All the returning values of the generators created by `g` are put into a list and returned by `flatMap(f)(g)`, preceded by the return value of `f` itself.

**Example**

`flatMap(x => range(0, x))(fromArray([3, 2, 6]))`, generates `0, 1, 2, 0, 1, 0, 1, 2, 3, 4, 5`

`flatMap((x, i) => returning(i)(range(0, x)))(fromArray([3, 2, 6]))`, returns `[undefined, 0, 1, 2]`

### fromArray

```typescript
function fromArrayfromArray<T, TReturn = any>(array: T[], returnValue?: TReturn): Generator<T, TReturn, void>
```

`fromArray` takes an array `array` generates, one by one, the elements in `array`.

Optionally `fromArray(array, value)` returns `value`

### head

```typescript
function head<T, TReturn = any, TNext = any> (n: number = 1, returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn | null, TNext>
```

`head(n)` takes a generator `g` and generates its first `n` (default `n` = 1) items.

If `g` runs out before reaching `n` elements, `head(n, value)(g)` returns the return value of `g`. Otherwise, it returns `value`.

### headWhile

```typescript
function headWhile<T, TReturn = any, TNext = any> (p: (_0: T, _1: number, _2: TNext) => boolean, returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`headWhile(p)(g)` generates items `e` of `g` as long `p(e, index, next)` holds (`index` is the index of `e` in `g` and `next` is the next value used to generate it)

If `g` finishes before finsing the item that fulfils `p`, `headWhile(p, v)(g)` returns `v`

### last

```typescript
function last<T, TReturn = any, TNext = any> (size: number = 1): (g: Generator<T, TReturn, TNext>) => Generator<T[], TReturn, TNext>
```

`last(size)(g)` generates arrays of `size` elements with the last elements generated of `g` (generating always one more). It returns the same as `g`.

**Example**

`last(3)(range())` generates [0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], ...

### map

```typescript
function map<T, U, TReturn = any, TNext = any> (f: (_0: T, _1: number, _2: TNext) => U): (g: Generator<T, TReturn, TNext>) => Generator<U, TReturn, TNext>
```

`map(f)(g)` generates items `f(e, i, n)` where `e` are items of `g`, `i` is the index of `e` in `g` and `n` is the `next` passed to get `e`.

`map(f)(g)` returns the same value as `g`.

### mixAll

```typescript
function* mixAllmixAll<T, TReturn = any, TNext = any> (...gs: Generator<T, TReturn, TNext>[]): Generator<T[], TReturn[], TNext>
```

`mixAll(g1, ..., gn)` generates items `[e1, ..., en]` where `ei` is an item of `gi` (generated with the same `next` value) until the last one of them finishes

When one generator `gi` finishes and returns a value, `mixAll(g1, ..., gn)` does not include this value in its yield. Instead, yields an `undefined` in location `i`.

When all the generators finish, `mixAll(g1, ..., gn)` returns an array with all its return values.

**Example**

* `mixAll (fromArray(['a', 'b', 'c'], 'd'), range(0, 4, 1, 100))` generates `['a', 0]`, `['b', 1]`, `['c', 2]`, `[undefined, 3]`, and returns `['d', 100]`

### mixRace

```typescript
function* mixRace<T, TReturn = any, TNext = any> (...gs: Generator<T, TReturn, TNext>[]): Generator<T, TReturn[], TNext> {
```

`mixRace(g1, ..., gn)` generates items `[e1, ..., en]` where `ei` is an item of `gi` (generated with the same `next` value) until the first one of them finishes

When one or more generators `gi` return `vi`, `mixRace(g1, ..., gn)` returns an array with `vi` in positions `i`, and `undefined` everywhere else

**Example**

* `mixRace (fromArray(['a', 'b', 'c'], 200), range(0, 4, 1, 100))` generates `['a', 0]`, `['b', 1]`, `['c', 2]` and returns `[200, undefined]`

### multicast

```typescript
export function multicast<T, TReturn = any> (n: number): (g: Generator<T, TReturn>) => Generator<T, TReturn>[]
```

`multicast(n)(g)` creates `n` independent copies of g. 

`g` is required to not have a type of `next`.

The return value of each copy is the same as that of the original generator `g`.

**Example**

If `[c1, c2] = multicast(2)(range())`, then we can consume all elements of c1 (thus consuming g) without consuming the elements of c2.

### pick

```typescript
function pick<T, TReturn = any, TNext = any> (indexes: number[], returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

The `i`-th element of `pick(indexes)(g)` is the `j`-th item of `g` (potentially `undefined`, if `g` does not have `j` items), where `j` is the `i`-th item in `indexes`

`pick(indexes)(g)` passes down to `g` the `next` value passed to `pick` for each `i` in `indexes`, which does not correspond to the items generated by `g`.

`pick(indexes)(g)` returns the returning value of `g` if it finished.

`pick(indexes, returnValue)(g)` returns `returnValue` when either `indexes` or `g` end.

### pipe

```typescript
function pipe<T>(...constructors: ((_: Generator<T>) => Generator<T>)[]): (generator: Generator<T>) => Generator<T>
```

`pipe(...c)(g)` generates items of `g` and passes them through the generator constructors `c_i`

**Example**

`pipe(skip(5), head(10), filter(x => x % 2 === 0))(range())` generates 6, 8, 10, 12, 14

### prepend

```typescript
function prepend<T, TReturn = any, TNext = any> (object: Generator<T, TReturn, TNext>): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`prepend(g1)(g2)` generates, first, all items from `g1`, and then all items from `g2`

`next` values passed to `prepend(g1)(g2)` are passed down to `g1`, first, and `g2`, after.

The return value of `g1` is ignored. The return value of `prepend(g1)(g2)` is that of `g2`.

**Example**

`prepend(range(0, 5))(range(5))` generates `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...`

### range

```typescript
function* range<TReturn = number>(start: number = 0, end: number = Infinity, step: number = 1, vReturn?: TReturn): Generator<number, TReturn, any>
```

`range(start?, end?, step?, returnValue?)` generates numbers from `start` (included) to `end` (excluded) distanced a `step`, either increasing or decreasing

If given a `returnValue`, `range` returns it when it reaches the end.

**Examples**

* `range()` generates `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`...
* `range(1, 10)` generates `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`
* `range(10, 1, 2)` generates `10`, `8`, `6`, `4`, `2`
* `range(10, 1, 2, 100)` generates `10`, `8`, `6`, `4`, `2` and returns `100`

### reduce

```typescript
function reduce<T, U = T, TReturn = any, TNext = any> (f: (_0: U, _1: T, _2: number, _3: TNext) => U, u: U): (g: Generator<T, TReturn, TNext>): Generator<U, TReturn, TNext>
```

`reduce(f, dflt)(g)` generates items `r[i] = f(r[i-1], e)`, and `r[0] = d` and returns the return value of `g`

**Example**

`reduce((acc, x) => acc + x, 0)(range(0, 5))` generates 0, 1, 3, 6, 10

### returning

```typescript
function returning<T, TReturn=any, TNext=any> (returnValue: TReturn): (g: Generator<T, any, TNext>) => Generator<T, TReturn, TNext>
```

`returning(value)(g)` generates the same as `g`, and when `g` ends, returns `value`

### returningMap

```typescript
function returningMap<T, TReturn=any, UReturn = TReturn, TNext=any> (returnMap: (_: TReturn, _1: number, _2: TNext) => UReturn) (g: Generator<T, any, TNext>) => Generator<T, TReturn, TNext>
```

`returningMap(f)(g)` generates the same as `g`, and when `g` returns `value`, `returningMap(f)(g)` returns `f(value, i, next)` (with `i` the length of `g` and `next` the value used to generate it)

### sequence

```typescript
function* sequence<T> (f: (..._: T[]) => T, ...initialValues: T[])
```

`sequence(f, ...initialValues)` generates, first, the initial values and, after, the values produced by the function f over the last values generated

**Example**

`sequence((a, b) => a + b, 1, 1)` generates the fibonacci sequence

### skip

```typescript
function skip<T, TReturn = any, TNext = any> (n: number = 0, returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`skip(n)(g)` skips `n` items `e` of `g`. After skipping the items, it generates the same as `g` and returns the same as `g`.

If `g` is shorter than `n`, `skip` returns `g`'s return value when it ends.

**Example**

`skip(5)(range(0, 10))` generates 5, 6, 7, 8, 9

### skipWhile

```typescript
function skipWhile<T, TReturn = any, TNext = any> (p: (_0: T, _1: number) => boolean, returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`skipWhile(p)(g)` skips items `e` of `g` as long `p(e, i)` holds (`i` is the index of `e` in `g`).

After skipping the items, it generates the same as `g` and returns either the specified value or, if not specified, the same as `g`.

**Example**

`skipWhile(x => x % 6 !== 5)(range(0, 10))` generates 5, 6, 7, 8, 9

### slice

```typescript
function slice<T, TReturn = any, TNext = any> (start: number = 0, end: number = Infinity, step: number = 1, returnValue?: TReturn): (_: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`slice(start, end, step)(g)` gets items indexed `i` on `g`, where 0 <= `start` <= `i` < `end`, and if `i` is an index, the next index is `i + step`.

**Example**

* `slice(5, 10)(range())` generates 5, 6, 7, 8, 9
* `slice(5, 10, 2)(range())` generates 5, 7, 9

### some

```typescript
function some<T, TReturn = any, TNext = any> (p: (_0: T, _1: number, _2: TNext) => boolean): (g: Generator<T, TReturn, TNext>) => Generator<boolean, T | null, TNext>
```

`some(p)(g)` generates false until an element of `g` satisfies a predicate, in which case it generates true.

It returns the value that fulfilled `p`, if some did, or `null`.

`some` does not apply `p` to the return value of `g`.

### sortInsert

```typescript
function sortInsert<T, TReturn = any, TNext = any> (item: T, sort: (_0: T, _1: T) => number): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

If `g` is a sorted generator (according to `sort`), then `sortInsert(item, sort)(g)` generates the items of `g` including `item` following order given by `sort`.

`sortInsert(item, sort)(g)` provides to `g` consecutive `next` values, irrespective of the insertion of the item.

**Example**

`sortInsert(5, (a, b) => a - b)(range(0, 10, 2))` generates 0, 2, 4, 5, 6, 8

### sortMerge

```typescript
function sortMerge<T, TReturn = any, TNext = any> (h: Generator<T, TReturn, TNext>, sort: (_0: T, _1: T) => number): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn[], TNext>
```

If `g` and `h` are sorted generators (according to `sort`), then `sortMerge(h, sort)(g)` generates the items of `g` and `h` following order given by `sort`.

`sortMerge(h, sort)(g)` returns `[v, w]` if `g` returns `v` and `h` returns `w`.

**Example**

`sortMerge(range(0, 10, 2), (a, b) => a - b)(range(1, 11, 2))` gives 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

### step

```typescript
function step<T, TReturn = any, TNext = any> (distance: number = 1, returnValue?: TReturn): (g: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>
```

`step(distance)(g)` gets the elements of `g` separated `distance` items between each.

`step(distance, returnValue)(g)` returns `returnValue` if specified. Otherwise, it returns the returned value of `g`.

**Example**

`step(5)(range())` generates 0, 5, 10, 15...

### tagFeed

```typescript
function* tagFeed<T, TReturn = any, TNext = T>(g: Generator<T, TReturn, TNext>): Generator<(T | TNext)[], (TReturn | TNext)[], TNext>
```
 
`tagFeed(g)` generates `[e, n]`, where `e` is an item generated by `g` and `n` is the next value passed to generate `e`.

`tagFeed(g)` returns `[r, n]`, where `r` is the return value of `r` and `n` is the next value passed to end `g`.

**Example**

`tagFeed(feed(range(0, 10))(feedMap(x => x * 2, 0)))`

### tap

```typescript
function tap<T, TResult = any, TNext = any> (f: (_0: T, _1: number, _2: TNext) => any): (g: Generator<T, TResult, TNext>) => Generator<T, TResult, TNext>
```
 
`tap(f)(g)` applies `f(e)` where `e` are items of `g`, and generates `e` unchanged

### toAsync

```typescript
function toAsync<T, TReturn = any, TNext = any> (h: (_: Generator<T, TReturn, TNext>) => Generator<T, TReturn, TNext>): (g: AsyncGenerator<T, TReturn, TNext>) => AsyncGenerator<T, TReturn, TNext>
```

`toAsync(f)` is a function that applies to an asynchronous generator `g` so that a non asynchronous operator `f` can operate with the values of `g`.

If `g` is an asynchronous generator, then `toAsync(f)(g)` is also an asynchronous generator.

### yieldReturnValue

```typescript
function* yieldReturnValue<T, TReturn=any, TNext=any> (g: Generator<T, TReturn, TNext>): Generator<T, TReturn, TNext>
```

`yieldReturnValue(g)` generates the same values as g, but at also yields the return value of `g`.
